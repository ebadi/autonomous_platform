/*
              Changelog:
________________________________________________________________________
|        NAME             |   DATE    |         Changes Made           |
  Alexander Rydevald       07-05-2023      1st draft speed sensor ECU
*/

/*
================================================
Include Arduino libraries to use in project

HOW TO INCLUDE NEW LIBRARIES: Add library in platformio.ini file under lib_deps and they will be downloaded automatically during compiling
This can be done manually or through platformio's library manager.
*/
#include <Arduino.h> // Must Be Included since the PlattformIO uses Arduino Framework
#include <math.h>

/* Include config files */
#include "pin_config.h"
/*
=================================================
Include custom Controller Area Network (CAN) Database for Autonomous Platform Generation 4.
Make sure this platformio project is located in the CAN_Nodes_Microcontroller_Code directory in order for the relative path to work
Module Libraries are located in: SHARED_HW_Node_Libraries
adding paths to each one is done in platformio.ini
*/
#include "AP4_CAN.h"
#include "SpeedSensorInterface.h"

/* Define and initialie global variables */
bool set_SW_filter = false;
AP4_CAN can_interface(CAN_CS_PIN, set_SW_filter);
uint32_t t;
bool recieved_interrupt = false;


uint8_t Velocity; //Variable to store readings from speed sensor

const int LM393 = PA0;    // Connect the sensor output to PA0 pin
volatile unsigned int pulseCount = 0;   // Variable to store the pulse count
unsigned long lastTime = 0;   // Variable to store the last time measurement
unsigned int rpm = 0;         // Variable to store the calculated RPM
unsigned int baud_rate = 9600;         // Variable to store the baud rate
const unsigned int pulsesPerRevolution = 2;   // Number of pulses generated by the sensor per revolution
const double wheelRadius = 0.3;  // Radius of the wheel in meters
const double pi = 3.14159; // Definition of pi

bool interupt_flag = false;
/* Include node specific library dependencies */
// From the lib folder within each project

/*
AP4 CAN read interrupt function
// Interuptfunction declaration*/ 
void AP4CANInterrupt();

// ---------------------------- CODE: ------------------------------

void countPulse() {
  pulseCount++;   // Increment pulse count on each rising edge of the sensor output
}

/*
Arduino setup function or also called init
*/
void setup() {
  // note that the void loop() does not have scope to read variables declared within the setup()

  //Serial is used for debugging purposes, USB-micro connection cable of the STM32 Bluepill
  Serial.begin(baud_rate);
  // Set LM393 as an input pin
  pinMode(LM393, INPUT);   
  // Attach interrupt on rising edge of LM393
  attachInterrupt(digitalPinToInterrupt(LM393), countPulse, RISING);
  // Check if a USB micro cable is connected and serial communication can be connected
  // otherwise, moves on
  bool break_while=true;
  uint32_t t = getCurrentMillis();
  while(!Serial && break_while)
  {
    uint32_t dt=getCurrentMillis()-t;
    if(dt > (u_int32_t)3000)
    {
      break_while=false;
    }
  }

  
  can_interface.InitMCP2515();
  //Serial.println("waiting 1 minute for raspberry pi to start!!!");
  //delay(60000);
  //  Set up of CAN buss, will be needed for every ECU:
  can_interface.InitMCP2515();
  int nr_can_bus_init_attempts = 0;
  int max_attempts = 500;
  // Tries 500 times to setup the CAN bus
  while(can_interface.InitMCP2515() == false && nr_can_bus_init_attempts < max_attempts)
  {
    Serial.println("  INIT OF CANBUSS FAILED! Waiting 1 second and retrying");
    nr_can_bus_init_attempts++;
    delay(1000);
  }
  
  /*
  Configure what CAN signals should be read from the CAN bus (by Id), any other message ID will be ignored!!
  */
  attachInterrupt(digitalPinToInterrupt(CAN_INTERRUPT_PIN), AP4CANInterrupt, LOW);

  Serial.println("Set up of CAN interface complete!");

  // Send speed sensor by ID (CAN_ID_GE_SPEED_SENSOR) once every second (100ms). 
  can_interface.AddPeriodicCanSend(CAN_ID_GET_SPEED_SENSOR,1000);
  
  

 

  pinMode(LED_BUILTIN, OUTPUT); //internal LED will light up!
  Serial.println("Init of ECU is Complete!");
  Serial.println("");
}

/*
"WHILE True-loop"
*/

void loop() {

  uint32_t t_time = getCurrentMillis();
  
  if(interupt_flag){
    //Serial.println("hello");
    interupt_flag=false;
  }
  can_interface.PeriodicCanSend();
  // the loop function runs over and over again forever
  if(recieved_interrupt)
  {
  // Updates each value in the can_interface object
  can_interface.InterruptReadCAN();
  }

  // Speed Sensor
  if (millis() - lastTime >= 1000) {   // Check if one second has passed
    unsigned int revolutions = pulseCount / pulsesPerRevolution;   // Calculate the number of revolutions
    
    rpm = (revolutions * 60);   // Calculate RPM based on the number of revolutions
    Velocity = (2 * pi * wheelRadius * rpm) / 60; // Convert RPM to velocity in meters per second
    
    pulseCount = 0;   // Reset pulse count for the next second
    lastTime = millis();   // Store the current time for the next comparison

    Serial.print("Velocity: ");
    Serial.println(Velocity);   // Print the calculated RPM value
    
    encode_can_0x5dc_Get_Velocity(&can_interface.can_storage_container,Velocity);

    can_interface.SendSingleCanFrame(CAN_ID_GET_SPEED_SENSOR);

  }

  

}

void AP4CANInterrupt() 
{
  // detects intrupt at the INT pin
  recieved_interrupt = true;
}
