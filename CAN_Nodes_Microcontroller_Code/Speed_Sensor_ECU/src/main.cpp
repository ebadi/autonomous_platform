/*
              Changelog:
________________________________________________________________________
|        NAME             |   DATE    |         Changes Made           |
  Alexander Rydevald       07-05-2023      1st draft speed sensor ECU
*/

/*
================================================
Include Arduino libraries to use in project

HOW TO INCLUDE NEW LIBRARIES: Add library in platformio.ini file under lib_deps and they will be downloaded automatically during compiling
This can be done manually or through platformio's library manager.
*/
#include <Arduino.h> // Must Be Included since the PlattformIO uses Arduino Framework
#include <math.h>
/* Include config files */
#include "pin_config.h"
/*
=================================================
Include custom Controller Area Network (CAN) Database for Autonomous Platform Generation 4.
Make sure this platformio project is located in the CAN_Nodes_Microcontroller_Code directory in order for the relative path to work
Module Libraries are located in: SHARED_HW_Node_Libraries
adding paths to each one is done in platformio.ini
*/
#include "AP4_CAN.h"
#include "SpeedSensorInterface.h"

/* Define and initialie global variables */
bool set_SW_filter = false;
AP4_CAN can_interface(CAN_CS_PIN, set_SW_filter);
uint32_t t;
bool received_interrupt = false;


double Velocity_LF,Velocity_RF,Velocity_LR,Velocity_RR ; //Variable to store readings from speed sensor

const int LM393_LeftFront = PA0;    // Connect the sensor output to PA1 pin
const int LM393_RightFront = PA1;    // Connect the sensor output to PA0 pin
const int LM393_LeftRear = PA2;    // Connect the sensor output to PA3 pin
const int LM393_RightRear = PA3;    // Connect the sensor output to PA2 pin


// Definition for interrupt handler in the speed sensor.
<<<<<<< HEAD
const long IgnoreWindow = 500 ; // define a time window in microseconds to ignore new edges to be handled
=======
const long IgnoreWindow = 100 ; // define a time window in microseconds to ignore new edges to be handled
>>>>>>> david_dev
//                   This implies a sample time of 2000 pulses/s, which should be fast enough to sample 1 KHz.

 unsigned long  NewEdgeTimeLF = 0,
                NewEdgeTimeRF = 0,
                NewEdgeTimeLR = 0,  
                NewEdgeTimeRR = 0 ;   // Variables to store the last time measurement

 unsigned int EdgeCntLF = 0,
              EdgeCntRF = 0,
              EdgeCntLR = 0,
              EdgeCntRR = 0 ;


const int can_schedule_time = 100 ; // Can schedule update time (in milliseconds)

volatile unsigned int pulseCount_RightFront = 0,
                      pulseCount_LeftFront  = 0,
                      pulseCount_RightRear  = 0,
                      pulseCount_LeftRear   = 0;   // Variable to store the pulse count
unsigned long lastTime = 0;   // Variable to store the last time measurement
unsigned int baud_rate = 9600;         // Variable to store the baud rate

// Not relevant in this section since we only send out pulses/s
const unsigned int pulsesPerRevolutionRear  = 60;   // Number of pulses generated by the sensor per revolution
const unsigned int pulsesPerRevolutionFront = 35;   // Number of pulses generated by the sensor per revolution

// Not relevant in this section since we don't send out speed
const double FrontWheelCircumference = 0.68 ;  // Radius of the front wheel in meters
const double RearWheelCircumference = 0.78;  // Radius of the rear wheel in meters

unsigned long test_time=0.0;


// const double pi = 3.14159; // Definition of pi

bool interupt_flag = false;
/* Include node specific library dependencies */
// From the lib folder within each project

/*
AP4 CAN read interrupt function
// Interuptfunction declaration*/ 
void AP4CANInterrupt();

// ---------------------------- CODE: ------------------------------


// Interrupt handlers for Speed sensor input pins.


// TODO: Consider to define a universal function.

void countPulse_LeftFront() {
  unsigned long Time=micros();   // Variables to store the last time measurement
  
  if (((Time-NewEdgeTimeLF)> IgnoreWindow ) || (EdgeCntLF == 0 )){
    NewEdgeTimeLF = Time ; 
    pulseCount_LeftFront++;   // Increment pulse count on a new edge of the sensor output
    EdgeCntLF = 0 ;
    }
  else { // Do not count the pulse if the Ignore window has not passed
    // enable these prins only for debug purpose
    // Serial.print(".") ;
    // Serial.println(Time);
    }
  // Count edges
  EdgeCntLF++ ;
}



void countPulse_RightFront() {
 unsigned long Time=micros();   // Variables to store the last time measurement
  
  if (((Time-NewEdgeTimeRF)> IgnoreWindow ) || (EdgeCntRF == 0 )){
    NewEdgeTimeRF = Time ; 
    pulseCount_RightFront++;   // Increment pulse count on a new edge of the sensor output
    EdgeCntRF = 0 ;
    }
  else { // Do not count the pulse if the Ignore window has not passed
    // enable these prins only for debug purpose
    // Serial.print(".") ;
    // Serial.println(Time);
    }
  // Count edges
  EdgeCntRF++ ;
}

void countPulse_LeftRear() {
  unsigned long Time=micros();   // Variables to store the last time measurement

  if (((Time-NewEdgeTimeLR)> IgnoreWindow ) || (EdgeCntLR == 0 )){
    NewEdgeTimeLR = Time ; 
    pulseCount_LeftRear++;   // Increment pulse count on a new edge of the sensor output
    EdgeCntLR = 0 ;
    }
  else { // Do not count the pulse if the Ignore window has not passed
    // enable these prins only for debug purpose
    // Serial.print(".") ;
    // Serial.println(Time);
    }
  // Count edges
  EdgeCntLR++ ;
}

void countPulse_RightRear() {
   unsigned long Time=micros();   // Variables to store the last time measurement

  if (((Time-NewEdgeTimeRR)> IgnoreWindow ) || (EdgeCntRR == 0 )){
    NewEdgeTimeRR = Time ; 
    pulseCount_RightRear++;   // Increment pulse count on a new edge of the sensor output
    EdgeCntRR = 0 ;
    }
  else { // Do not count the pulse if the Ignore window has not passed
    // enable these prins only for debug purpose
    // Serial.print(".") ;
    // Serial.println(Time);
    }
  // Count edges
  EdgeCntRR++ ;
}


/*
Arduino setup function or also called init
*/
void setup() {
  // note that the void loop() does not have scope to read variables declared within the setup()

  //Serial is used for debugging purposes, USB-micro connection cable of the STM32 Bluepill
  Serial.begin(baud_rate);
  // Set LM393 as an input pin
  pinMode(LM393_LeftFront, INPUT);   
  pinMode(LM393_RightFront, INPUT);   
  pinMode(LM393_LeftRear, INPUT);   
  pinMode(LM393_RightRear, INPUT);   
    // Attach interrupt on rising edge of LM393
  attachInterrupt(digitalPinToInterrupt(LM393_LeftFront), countPulse_LeftFront, FALLING);
  attachInterrupt(digitalPinToInterrupt(LM393_RightFront), countPulse_RightFront, FALLING);
  attachInterrupt(digitalPinToInterrupt(LM393_LeftRear), countPulse_LeftRear, FALLING);
  attachInterrupt(digitalPinToInterrupt(LM393_RightRear), countPulse_RightRear, FALLING);
  // Check if a USB micro cable is connected and serial communication can be connected
  // otherwise, moves on
  bool break_while=true;
  uint32_t t = getCurrentMillis();
  while(!Serial && break_while)
  {
    uint32_t dt=getCurrentMillis()-t;
    if(dt > (u_int32_t)3000)
    {
      break_while=false;
    }
  }

  
  can_interface.InitMCP2515();
  //Serial.println("waiting 1 minute for raspberry pi to start!!!");
  //delay(60000);
  //  Set up of CAN buss, will be needed for every ECU:
  can_interface.InitMCP2515();
  int nr_can_bus_init_attempts = 0;
  int max_attempts = 500;
  // Tries 500 times to setup the CAN bus
  while(can_interface.InitMCP2515() == false && nr_can_bus_init_attempts < max_attempts)
  {
    Serial.println("  INIT OF CANBUSS FAILED! Waiting 1 second and retrying");
    nr_can_bus_init_attempts++;
    delay(1000);
  }
  
  /*
  Configure what CAN signals should be read from the CAN bus (by Id), any other message ID will be ignored!!
  */
  attachInterrupt(digitalPinToInterrupt(CAN_INTERRUPT_PIN), AP4CANInterrupt, LOW);

  Serial.println("Set up of CAN interface complete!");

  // Send speed sensor by ID (CAN_ID_GE_SPEED_SENSOR) once every second (100ms). 
  can_interface.AddPeriodicCanSend(CAN_ID_GET_SPEED_SENSOR,1000);
  
  

 

  pinMode(LED_BUILTIN, OUTPUT); //internal LED will light up!
  Serial.println("Init of ECU is Complete, jonguh!!!");
  Serial.println("");
}

/*
"WHILE True-loop"
*/

void loop() {

  uint32_t t_time = getCurrentMillis();
  
  if(interupt_flag){
    Serial.println("hello");
    interupt_flag=false;
  }
  can_interface.PeriodicCanSend();
  // the loop function runs over and over again forever
  if(received_interrupt)
  {
  // Updates each value in the can_interface object
  can_interface.InterruptReadCAN();
  }

  // Speed Sensor
  if (millis() - lastTime >= can_schedule_time) {   // Check if "can_schedule_time" has passed. 
<<<<<<< HEAD
    
=======
>>>>>>> david_dev
    lastTime = millis();   // Store the current time for the next comparison
// debug messages to serial terminal
    Serial.print("CAN schedule Time base (ms): ");
    Serial.print(can_schedule_time);

    Serial.print("Pulse counts (LF,RF,LR,RR): ");
    Serial.print(pulseCount_LeftFront ); Serial.print("\t");
    Serial.print(pulseCount_RightFront);Serial.print("\t");
    Serial.print(pulseCount_LeftRear  );Serial.print("\t");
    Serial.println(pulseCount_RightRear);
      
// Encode the values in the buffer

    encode_can_0x5dc_SpeedSensorLF_PulseCnt(&can_interface.can_storage_container,pulseCount_LeftFront);
<<<<<<< HEAD
    encode_can_0x5dc_SpeedSensorRF_PulseCnt(&can_interface.can_storage_container,pulseCount_LeftFront);
    encode_can_0x5dc_SpeedSensorLR_PulseCnt(&can_interface.can_storage_container,pulseCount_LeftFront);
    encode_can_0x5dc_SpeedSensorRR_PulseCnt(&can_interface.can_storage_container,pulseCount_LeftFront);
    encode_can_0x5dc_SpeedSensorRR_PulseCnt(&can_interface.can_storage_container,pulseCount_LeftFront);
=======
    encode_can_0x5dc_SpeedSensorRF_PulseCnt(&can_interface.can_storage_container,pulseCount_RightFront);
    encode_can_0x5dc_SpeedSensorLR_PulseCnt(&can_interface.can_storage_container,pulseCount_LeftRear);
    encode_can_0x5dc_SpeedSensorRR_PulseCnt(&can_interface.can_storage_container,pulseCount_RightRear);
>>>>>>> david_dev
    encode_can_0x5dc_SpeedSensorSampleTime(&can_interface.can_storage_container, can_schedule_time);
    
    

// Send the buffer on CAN

    can_interface.SendSingleCanFrame(CAN_ID_GET_SPEED_SENSOR);

    // Reset pulse count values for the next loop.

    pulseCount_LeftFront = 0;   
    pulseCount_RightFront = 0;   // Reset pulse count for the next second
    pulseCount_LeftRear = 0;   // Reset pulse count for the next second
    pulseCount_RightRear = 0;   // Reset pulse count for the next second

  }

  

}

void AP4CANInterrupt() 
{
  // detects intrupt at the INT pin
  received_interrupt = true;
}